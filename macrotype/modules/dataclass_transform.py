from __future__ import annotations

import dataclasses
from typing import Any

from .scanner import ModuleInfo
from .symbols import ClassSymbol

# Defaults used when recreating a ``@dataclass`` decorator.
_DATACLASS_DEFAULTS: dict[str, Any] = {
    "init": True,
    "repr": True,
    "eq": True,
    "order": False,
    "unsafe_hash": False,
    "frozen": False,
    "match_args": True,
    "kw_only": False,
    "slots": False,
    "weakref_slot": False,
}

# Methods automatically generated by ``dataclasses`` which should not appear in
# generated stubs.
_AUTO_DATACLASS_METHODS = {
    "__init__",
    "__repr__",
    "__eq__",
    "__lt__",
    "__le__",
    "__gt__",
    "__ge__",
    "__hash__",
    "__setattr__",
    "__delattr__",
    "__getstate__",
    "__setstate__",
    "_dataclass_getstate",
    "_dataclass_setstate",
    "__getattribute__",
    "__replace__",
}


def _dataclass_auto_methods(
    params: dataclasses._DataclassParams | None,
) -> set[str]:
    """Return the dataclass-generated methods based on *params*."""

    if params is None:
        return set(_AUTO_DATACLASS_METHODS)

    auto_methods = {
        "__init__",
        "__repr__",
        "__getstate__",
        "__setstate__",
        "_dataclass_getstate",
        "_dataclass_setstate",
        "__getattribute__",
        "__replace__",
    }
    if params.eq:
        auto_methods.add("__eq__")
    if params.order:
        auto_methods.update({"__lt__", "__le__", "__gt__", "__ge__"})
    if params.frozen:
        auto_methods.update({"__setattr__", "__delattr__"})
    if params.eq and (params.frozen or params.unsafe_hash):
        auto_methods.add("__hash__")
    return auto_methods


def _dataclass_decorator(klass: type) -> str | None:
    """Return the ``@dataclass`` decorator text for *klass*."""

    if not (dataclasses.is_dataclass(klass) or hasattr(klass, "__dataclass_fields__")):
        return None

    params = getattr(klass, "__dataclass_params__", None)
    args: list[str] = []
    if params is not None:
        for name, default in _DATACLASS_DEFAULTS.items():
            if name == "match_args" and not hasattr(params, "match_args"):
                continue
            val = getattr(params, name, default)
            if name == "slots" and not hasattr(params, name):
                val = not hasattr(klass, "__dict__")
            elif name == "weakref_slot" and not hasattr(params, name):
                val = "__weakref__" in getattr(klass, "__slots__", ())
            if val != default:
                args.append(f"{name}={val}")

    return "dataclass" + (f"({', '.join(args)})" if args else "")


def _transform_class(sym: ClassSymbol, cls: type) -> None:
    deco = _dataclass_decorator(cls)
    if deco:
        params = getattr(cls, "__dataclass_params__", None)
        auto_methods = _dataclass_auto_methods(params)
        sym.members = tuple(m for m in sym.members if m.name not in auto_methods)
        sym.decorators = sym.decorators + (deco,)

    for m in sym.members:
        if isinstance(m, ClassSymbol):
            inner = getattr(cls, m.name, None)
            if isinstance(inner, type):
                _transform_class(m, inner)


def transform_dataclasses(mi: ModuleInfo) -> None:
    """Attach dataclass decorators and strip auto methods within ``mi``."""

    for sym in mi.symbols:
        if isinstance(sym, ClassSymbol):
            cls = getattr(mi.mod, sym.name, None)
            if isinstance(cls, type):
                _transform_class(sym, cls)
