from __future__ import annotations

"""Synthesize enum members and strip autogenerated methods."""

import enum

from macrotype.modules.symbols import AliasSymbol, ClassSymbol, ModuleInfo, Site


def _enum_members(klass: enum.EnumMeta) -> list[AliasSymbol]:
    """Return alias symbols for enum members in *klass*."""

    members: list[AliasSymbol] = []
    for member_name, member in klass.__members__.items():
        site = Site(role="alias_value", annotation=member.value)
        members.append(AliasSymbol(name=member_name, value=site))
    return members


def _auto_enum_methods(klass: type) -> set[str]:
    """Return method names automatically added to enum classes."""

    auto = {"_generate_next_value_", "__new__"}
    for name in ("__repr__", "__str__", "__format__"):
        value = klass.__dict__.get(name)
        if getattr(value, "__module__", None) == "enum":
            auto.add(name)
    if issubclass(klass, enum.Flag):
        auto.update(
            {
                "__or__",
                "__and__",
                "__xor__",
                "__ror__",
                "__rand__",
                "__rxor__",
                "__invert__",
            }
        )
    return auto


def _transform_class(sym: ClassSymbol, cls: type) -> None:
    if isinstance(cls, enum.EnumMeta):
        auto = _auto_enum_methods(cls)
        members = [m for m in sym.members if m.name not in auto]
        members = _enum_members(cls) + members
        sym.members = tuple(members)

    for m in sym.members:
        if isinstance(m, ClassSymbol):
            inner = getattr(cls, m.name, None)
            if isinstance(inner, type):
                _transform_class(m, inner)


def transform_enums(mi: ModuleInfo) -> None:
    """Expand enum members and strip autogenerated methods in ``mi``."""

    for sym in mi.get_all_symbols():
        if isinstance(sym, ClassSymbol):
            cls = getattr(mi.mod, sym.name, None)
            if isinstance(cls, type):
                _transform_class(sym, cls)
