from typing import Any, Callable, ClassVar, Concatenate, Final, Literal, LiteralString, NoReturn, Never, TypeGuard, TypeVar, TypeVarTuple, TypedDict, ParamSpec, Unpack, overload, final, override
from collections.abc import AsyncIterator
from dataclasses import dataclass
from math import sin

T = TypeVar('T')
P = ParamSpec('P')
Ts = TypeVarTuple('Ts')
InferredT = TypeVar('InferredT', infer_variance=True)
TDV = TypeVar('TDV')

ANNOTATED_CLASSVAR: ClassVar[int]

class OverrideChild(Basic):
    @override
    def copy[T](self, param: T) -> T: ...

class OverrideLate(Basic):
    @classmethod
    @override
    def cls_override(cls) -> int: ...
    @staticmethod
    @override
    def static_override() -> int: ...

@overload
def loop_over(x: bytes) -> str: ...
@overload
def loop_over(x: bytearray) -> str: ...

@dataclass
class InitVarExample:
    x: int
    def __post_init__(self, init_only: int) -> None: ...

def as_tuple[*Ts](*args: Unpack[Ts]) -> tuple[Unpack[Ts]]: ...

class Variadic[Unpack[Ts]]:
    def __init__(self, *args: Unpack[Ts]) -> None: ...
    def to_tuple(self) -> tuple[Unpack[Ts]]: ...

class Info(TypedDict):
    name: str
    age: int

def with_kwargs(**kwargs: Unpack[Info]) -> Info: ...

def sum_of(*args: tuple[int]) -> int: ...

def dict_echo(**kwargs: dict[str, Any]) -> dict[str, Any]: ...

def prepend_one[**P](fn: Callable[Concatenate[int, P], int]) -> Callable[P, int]: ...

def use_params[**P](*args: P.args, **kwargs: P.kwargs) -> int: ...

def do_nothing() -> None: ...

def always_raises() -> NoReturn: ...

def never_returns() -> Never: ...

def is_str_list(val: list[object]) -> TypeGuard[list[str]]: ...

FINAL_VAR_WITH_VALUE: Final[int]
PLAIN_FINAL_VAR: Final
SIN_ALIAS = sin
PI_ALIAS: float
def local_alias_target(x: int) -> int: ...
LOCAL_ALIAS = local_alias_target
def echo_literal(value: LiteralString) -> LiteralString: ...
NONE_VAR: None
async def async_add_one(x: int) -> int: ...
async def gen_range(n: int) -> AsyncIterator[int]: ...
@final
def final_func(x: int) -> int: ...

class EmittedMap:
    @overload
    def __getitem__(self, key: Literal['a']) -> Literal[1]: ...
    @overload
    def __getitem__(self, key: Literal['b']) -> Literal[2]: ...
    def __getitem__(self, key: Any): ...
