# Generated via: macrotype macrotype
# Do not edit by hand
from dataclasses import _DataclassParams, dataclass
from enum import EnumType
from functools import partialmethod
from inspect import Signature
from macrotype.meta_types import get_overloads
from typing import Any, Callable

ModuleType = module

_INDENT: str

_MODULE_ALIASES: dict[str, str]

_get_overloads = get_overloads

class PyiElement:
    def render(self, indent: int) -> list[str]: ...
    @staticmethod
    def _space(indent: int) -> str: ...

@dataclass
class PyiNamedElement(PyiElement):
    name: str
    used_types: set[type]
    line: None | int

_DATACLASS_DEFAULTS: dict[str, Any]

def _dataclass_auto_methods(params: None | _DataclassParams) -> set[str]: ...

_ATTR_DECORATORS: dict[type, tuple[str, str]]

_ALIAS_TYPES: tuple[type, ...]

def _unwrap_decorated_function(obj: Any) -> Callable[..., Any] | None: ...

def _unwrap_descriptor(obj: Any) -> Any | None: ...

def _annotation_for_value(value: Any) -> Any: ...

def _make_literal_overload(fn: Callable[..., Any], args: tuple, kwargs: dict, result: Any) -> Callable[..., Any]: ...

def _extract_partialmethod(pm: partialmethod, klass: type, name: str, *, globalns: dict[str, Any]) -> Callable[..., Any]: ...

def _get_class_function(attr: Any, name: str, klass: type, *, globalns: dict[str, Any]) -> Callable[..., Any] | None: ...

def _dataclass_decorator(klass: type) -> None | tuple[str, set[type]]: ...

@dataclass
class PyiVariable(PyiNamedElement):
    type_str: str
    def render(self, indent: int) -> list[str]: ...
    @classmethod
    def from_assignment(cls, name: str, value: Any) -> PyiVariable: ...

@dataclass
class PyiAlias(PyiNamedElement):
    value: str
    keyword: str
    type_params: list[str]
    def render(self, indent: int) -> list[str]: ...

def _collect_args(sig: Signature, hints: dict[str, Any]) -> tuple[list[tuple[str, None | str]], set[type]]: ...

def _collect_type_params(fn: Callable[..., Any], hints: dict[str, Any], exclude_params: None | set[str]) -> tuple[list[str], set[type]]: ...

def _collect_decorators(decorators: None | list[str], fn: Callable[..., Any], *, skip_final: bool) -> tuple[list[str], set[type]]: ...

def _typeddict_info(klass: type) -> tuple[list[type], None | bool]: ...

def _class_decorators(klass: type) -> tuple[list[str], set[type], bool]: ...

def _namedtuple_members(klass: type, *, globalns: dict[str, Any]) -> tuple[list[PyiElement], set[type]]: ...

def _namedtuple_bases(klass: type, type_params: list[str], *, globalns: dict[str, Any]) -> tuple[list[str], set[type]]: ...

def _typeddict_bases(klass: type, bases: list[type]) -> tuple[list[str], set[type]]: ...

def _normal_class_bases(klass: type, type_params: list[str], *, globalns: dict[str, Any]) -> tuple[list[str], set[type]]: ...

def _class_variables(klass: type, *, globalns: dict[str, Any], is_typeddict: bool, td_bases: list[type], is_dataclass_obj: bool) -> tuple[list[PyiElement], set[type]]: ...

def _enum_members(klass: EnumType) -> list[PyiElement]: ...

def _auto_methods(klass: type, *, is_dataclass_obj: bool, is_enum: bool) -> set[str]: ...

def _protocol_skip_methods(klass: type) -> set[str]: ...

def _function_members(fn: Callable[..., Any], *, class_params: set[str], globalns: dict[str, Any], localns: dict[str, Any]) -> tuple[list[PyiFunction], set[type]]: ...

def _descriptor_members(attr_name: str, attr: Any, *, class_params: set[str], globalns: dict[str, Any], localns: dict[str, Any]) -> tuple[list[PyiElement], set[type]]: ...

def _class_methods(klass: type, *, globalns: dict[str, Any], class_params: set[str], is_enum: bool, is_dataclass_obj: bool) -> tuple[list[PyiElement], set[type]]: ...

@dataclass
class PyiFunction(PyiNamedElement):
    args: list[tuple[str, None | str]]
    return_type: str
    decorators: list[str]
    type_params: list[str]
    is_async: bool
    def render(self, indent: int) -> list[str]: ...
    @classmethod
    def from_function(cls, fn: Callable[..., Any], decorators: None | list[str], exclude_params: None | set[str], *, skip_final: bool, globalns: None | dict[str, Any], localns: None | dict[str, Any]) -> PyiFunction: ...

@dataclass
class PyiClass(PyiNamedElement):
    bases: list[str]
    type_params: list[str]
    body: list[PyiElement]
    typeddict_total: None | bool
    decorators: list[str]
    def render(self, indent: int) -> list[str]: ...
    @classmethod
    def from_class(cls, klass: type) -> PyiClass: ...

class _ModuleBuilder:
    def __init__(self, mod: module, line_map: None | dict[str, int]) -> None: ...
    def _add(self, item: PyiElement) -> None: ...
    def _format_annotation(self, annotation: Any, name: str) -> str: ...
    def _handle_alias(self, name: str, obj: Any) -> bool: ...
    def _handle_foreign_variable(self, name: str, obj: Any) -> bool: ...
    def _handle_function(self, name: str, obj: Any) -> bool: ...
    def _handle_class(self, name: str, obj: Any) -> bool: ...
    def _handle_newtype(self, name: str, obj: Any) -> bool: ...
    def _handle_alias_types(self, name: str, obj: Any) -> bool: ...
    def _handle_constant(self, name: str, obj: Any) -> bool: ...
    def _process_object(self, name: str, obj: Any) -> None: ...
    def _remaining_annotations(self) -> None: ...
    def _imports(self) -> list[str]: ...
    def build(self, *, header_comments: None | list[str], comments: None | dict[int, str]) -> PyiModule: ...

@dataclass
class PyiModule:
    imports: list[str]
    body: list[PyiElement]
    headers: list[str]
    comments: dict[int, str]
    def render(self, indent: int) -> list[str]: ...
    @classmethod
    def from_module(cls, mod: module) -> PyiModule: ...
